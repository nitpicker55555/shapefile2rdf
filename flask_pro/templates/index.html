<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Interpreter</title>
    <script src="../static/js/jquery-2.1.1.js"></script>
    <script src="../static/js/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link rel="stylesheet" href="../static/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../static/css/github-dark-dimmed.min.css">
    <link rel="stylesheet" href="../static/css/style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- å¼•å…¥ wellknown åº“æ¥è§£æ WKT -->
    <script src="https://unpkg.com/wellknown/wellknown.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <!--<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />-->
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <style>
        .container {
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .code-interpreter {
            font-style: italic;
            font-weight: bold;
            font-size: 50px;
        }
        #map-container {
            position: absolute; /* æˆ–è€…ä½¿ç”¨ position: fixed; æ ¹æ®éœ€è¦ */
            bottom: 100px; /* è·ç¦»çª—å£åº•éƒ¨100px */
            /*left: 20px; !* è·ç¦»çª—å£å·¦è¾¹ç¼˜50px *!*/
            right: 20px; /* è·ç¦»çª—å£å³è¾¹ç¼˜50px */
            width: 600px;
            height: 500px; /* é«˜åº¦ä¸º600px */
            background-color: #f0f0f0; /* èƒŒæ™¯è‰²ï¼Œä»…ä½œä¸ºç¤ºä¾‹ */
            visibility : hidden;
            font-size: medium;

        }
        .block-button {
            display: inline-block;
            margin: 10px;
            padding: 10px 20px;
            background-color: grey;
            color: white;
            border: none;
            border-radius: 15px;
            opacity: 0.7;
            text-align: center;
            cursor: pointer;
            transition: background-color 1s;
        }

        .block-button:hover {
            background-color: black;
            opacity: 1.0;
        }

        .leaflet-control-custom {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            left: 10px;

            /*border: 1px solid #fff;*/
            backdrop-filter: blur(10px);
            width: 200px;
            overflow: hidden;
            transition: top 0.3s ease-in-out;
            position: absolute;
            top: 50px; /* Initial top position below toggle */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add shadow */
            max-height: 500px;
            overflow-y: auto;
        }
        .leaflet-control-toggle {
            top: 10px; /* è·ç¦»çª—å£é¡¶éƒ¨çš„è·ç¦» */
            left: 10px;
            padding: 5px;
            border: none;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            width: 200px; /* Same width as controls */
            text-align: center;
            position: absolute;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add shadow */

        }
        .toggle_top{
            top: 10px; /* Position of toggle button */
            left: 10px;
            width: 200px; /* Same width as controls */
            position: fixed;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Add shadow */

        }
        .toggle-btn {
            margin: 5px 0;
            padding: 5px;
            width: calc(100% - 10px);
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            cursor: pointer;
            color: white;
            font-size: small;

        }
        .description {
            font-size: 14px;
            letter-spacing: 6px; /* å¢åŠ å­—é—´è· */
            display: block; /* æˆ–è€…ä½¿ç”¨flexç­‰å…¶ä»–å¸ƒå±€æ–¹å¼æ¥æ§åˆ¶å®½åº¦ */
            /* è®¾å®šå®½åº¦ä»¥å°è¯•ä¸ä¸Šæ–¹æ–‡æœ¬å®½åº¦åŒ¹é… */
            max-width: 600px; /* å‡è®¾ä¸Šæ–¹æ–‡æœ¬çš„æœ€å¤§å®½åº¦ä¸º600px */
            margin: 10px auto; /* å±…ä¸­æ˜¾ç¤º */
        }
        .red-button {
            background-color: red;
        }
        .leaflet-control-layers{
            display: none;
        }
        .custom-rect {
            display: block;
            border-radius: 10px;
            padding: 5px 10px;
            font-style: italic;
            background: linear-gradient(135deg, #1e90ff, #87cefa);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);

            position: relative;
            margin-bottom: 10px; /* è°ƒæ•´é—´è· */
        }

        .plan-label {
            display: inline-block;
            background-color: gray;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            margin-right: 5px;
            font-size: 12px;
            position: absolute;
            top: -10px;
            left: -10px;
        }
        .plan-label-map {
            display: inline-block;
            background-color: green;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            font-size: 12px;
            position: absolute;
            top:-10px;
            left: 25px;
        }
        .map-button {
            display: block;
            border-radius: 10px;
            padding: 5px 10px;
            background: linear-gradient(135deg, #800080, #dda0dd);
            color: white;
            border: none;
            cursor: pointer;
            position: relative;
            margin-bottom: 10px; /* è°ƒæ•´é—´è· */
        }

        #chatWindow {

            border: 1px solid #ccc;
            /*padding: 10px;*/
            overflow-y: auto; /* å†…å®¹è¶…å‡ºæ—¶åœ¨å…ƒç´ å†…éƒ¨æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            position: absolute; /* æˆ–è€…ä½¿ç”¨ position: fixed; æ ¹æ®éœ€è¦ */
            bottom: 100px; /* è·ç¦»çª—å£åº•éƒ¨100px */
            left: 20px; /* è·ç¦»çª—å£å·¦è¾¹ç¼˜50px */
            /*right: 20px; !* è·ç¦»çª—å£å³è¾¹ç¼˜50px *!*/
            width: 600px;
            height: 500px; /* é«˜åº¦ä¸º600px */
            /*margin: -30px 20px 5px; !* ä¸Šã€å·¦å³ã€ä¸‹çš„å¤–è¾¹è· *!*/
            /*width: calc(100% - 40px); !* è°ƒæ•´å®½åº¦ä»¥è€ƒè™‘å·¦å³çš„è¾¹è· *!*/
            /*max-height: calc(50vh); !* æœ€å¤§é«˜åº¦ä»¥é¿å…çª—å£æ»šåŠ¨æ¡ *!*/


        }
        .night-mode {
            background-color: black;
            color: white;
        }

        /* ä½ å¯èƒ½è¿˜éœ€è¦ä¸ºç‰¹å®šå…ƒç´ å®šä¹‰å¤œé—´æ¨¡å¼çš„æ ·å¼ */
        .night-mode p, .night-mode h1, .night-mode h2, .night-mode h3 {
            color: white; /* ç¡®ä¿æ‰€æœ‰æ–‡å­—éƒ½æ˜¯ç™½è‰² */
        }
        .night-mode button {
            background-color: #757575; /* ç°è‰²èƒŒæ™¯ */
            color: white; /* ç™½è‰²æ–‡å­— */
            /*border: none; !* å¯é€‰ï¼Œç§»é™¤è¾¹æ¡† *!*/
        }

        /* å¦‚æœä½ æœ‰ä½¿ç”¨ç‰¹å®šç±»åçš„æŒ‰é’®ï¼Œä¹Ÿå¯ä»¥ç›¸åº”åœ°ä¸ºå®ƒä»¬å®šä¹‰æ ·å¼ */
        .night-mode .your-button-class {
            background-color: #757575; /* ç°è‰²èƒŒæ™¯ */
            color: white; /* ç™½è‰²æ–‡å­— */
        }
        .input-button-container {
            position: fixed; /* ä½¿ç”¨å›ºå®šå®šä½ */
            bottom: 20px; /* è·ç¦»çª—å£åº•éƒ¨20px */
            left: 20px; /* è·ç¦»çª—å£å·¦è¾¹50px */
            right: 20px; /* è·ç¦»çª—å£å³è¾¹50px */

            display: flex; /* ä½¿ç”¨flexå¸ƒå±€ */
            justify-content: space-between; /* ä½¿è¾“å…¥æ¡†å’ŒæŒ‰é’®åˆ†å¸ƒåœ¨ä¸¤ç«¯ */
            align-items: center; /* å‚ç›´å±…ä¸­å¯¹é½ */
        }

        #upload-btn,#inputField, #confirmButton {
            height: 40px; /* è®¾ç½®è¾“å…¥æ¡†å’ŒæŒ‰é’®çš„é«˜åº¦ */
            line-height: 40px; /* è®¾ç½®è¡Œé«˜ä»¥å‚ç›´å±…ä¸­æ–‡æœ¬ */
        }

        #inputField {
            width: 80%; /* è¾“å…¥æ¡†å æ®å¤§éƒ¨åˆ†ç©ºé—´ */
            margin-right: 5px; /* å’ŒæŒ‰é’®ä¹‹é—´ç•™å‡ºä¸€äº›é—´éš” */
            margin-left: 5px; /* å’ŒæŒ‰é’®ä¹‹é—´ç•™å‡ºä¸€äº›é—´éš” */
        }

        #confirmButton {
            width: 30%; /* æŒ‰é’®å æ®å‰©ä½™ç©ºé—´ */
        }


        .fullscreen {
            width: 100% !important;
            height: 100vh !important;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 999;
            margin: 0 !important;    /* No margin */
            padding: 0 !important;   /* No padding */
        }
        .custom-cluster-icon {
            border-radius: 50%;
            color: white;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            font-size: 14px;
        }
    </style>


</head>
<body>
<!--    <div id="markdownContainer"></div>-->
<p class="lead text-center">
    <a  style="display: inline-block;" class="lead text-center" onclick="location.href='question'" style="color:red;">      Questions    |       </a>
    <a style="display: inline-block;"  class="lead text-center" id="my-p" style="color:blue;"> </a>
    <button id="nightModeToggle">ğŸŒ™</button>
    <br>
    <!--    <input type="text" id="subscribe" placeholder="è¾“å…¥é‚®ç®±è®¢é˜…æ›´æ–°:)...">-->
    <!--    <button id="submit_email">æäº¤</button>-->
</p>

<input type="file" id="file-input" style="display: none;" />
<div id="chatWindow" style="display: none"></div>
<div class="container" id="title">
    <span class="code-interpreter">Geo-QA</span>
    <div class="description"></div>
    <button class="rectangle-btn"  onclick="showNumber('Show buildings 100m around forest in Munich Maxvorstadt')">Show buildings 100m around forest</button>
    <br>
    <br>
    <button class="rectangle-btn"  onclick="showNumber('Show buildings in greenery in Munich Maxvorstadt')">Show buildings in greenery</button>
    <br>
    <br>
    <button class="rectangle-btn"  onclick="showNumber('Where is good for agriculture in Munich Maxvorstadt')">Where is good for agriculture</button>
    <br>
    <br>
    <button class="rectangle-btn"  onclick="showNumber('Park which has buildings inside in Munich Maxvorstadt')">Park which has buildings inside</button>
    <br>
    <br>
    <button class="rectangle-btn"  onclick="showNumber('Where are the rivers in Munich')">Where are the rivers</button>
    <!--    <button class="rectangle-btn"  onclick="showNumber('åˆ†ææˆ‘ä¸Šä¼ çš„æ–‡ä»¶')">Upload your ttl file</button>-->
</div>
<!--<button onclick="location.href='/question'">Go to Questions</button>-->
<div class="input-button-container">
    <!--    <input type="button" id="upload-btn" class="your-button-class" value="Upload" onclick="document.getElementById('file-input').click();" />-->


    <textarea type="text" id="inputField" class="your-button-class" placeholder="Input question..."></textarea>
    <button id="confirmButton" class="your-button-class">submit</button>
    <button id="debug_mode" class="your-button-class">debug</button>
</div>
<div id="map-container" ></div>

<script>
    // function uploadFile() {
    //
    var sid=''
    const usedElements = [];
    var allControls = [];
    var currentIndex = 0;
    const color_list=['#756bb1',
        '#3182bd',
        '#e78ac3',
        '#31a354',
        '#6baed6',
        '#74c476',
        '#fb8072',
        '#fdb462',
        '#bc80bd',
        '#8da0cb',
        '#fdd0a2',
        '#66c2a5',
        '#e6550d',
        '#fdae6b',
        '#a1d99b',
        '#636363',
        '#ffd92f',
        '#9ecae1',
        '#b3b3b3']

    var first_time_englischer_garten_error=true

    function showNumber(text) {
        if(text==="åˆ†ææˆ‘ä¸Šä¼ çš„æ–‡ä»¶"){
            document.getElementById('upload-btn').click()
        }else {
            var numberInput = document.getElementById("inputField");
            numberInput.value = text;
        }

    }
    // /}
    document.getElementById('nightModeToggle').addEventListener('click', function() {
        document.body.classList.toggle('night-mode');
    });
    var letters = '0123456789ABCDEF';
    var color_dict = {}; // å­˜å‚¨æ ‡ç­¾ä¸é¢œè‰²çš„æ˜ å°„
    var history_colors = new Set(); // å­˜å‚¨å†å²é¢œè‰²ä»¥é¿å…é‡å¤
    var count = 0; // åˆå§‹åŒ–è®¡æ•°å™¨
    var button_index=0


    var wait_button=[]
    var map_button_dict={}
    function add_map_button(map_data,targetText) {

        map_button_dict[targetText]=map_data



    }

    function observeDOMChanges() {
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE && (node.className==='custom-rect'||node.classList.contains('custom-rect'))) {
                        checkAndUpdateElement(node);
                    }
                });
            });
        });

        observer.observe(document.body, { childList: true, subtree: true });
    }
    function checkAndUpdateElement(element) {

        const divClone = element.cloneNode(true);

        // ç§»é™¤å…‹éš†å…ƒç´ ä¸­çš„ <span> å…ƒç´ 
        const span = divClone.querySelector('.plan-label');
        if (span) {
            span.remove();
        }
        const span_map = divClone.querySelector('.plan-label-map');
        if (span_map) {
            span_map.remove();
        }

        // è·å–å‰©ä½™æ–‡æœ¬å†…å®¹ï¼Œå¹¶å»é™¤å‰åçš„ç©ºæ ¼
        const desiredText = divClone.textContent.trim();
        // console.log(desiredText)

        if (desiredText in map_button_dict) {

            console.log(desiredText,'dom detect',element)
            // rect.classList.remove('custom-rect');
            element.className='map-button';
            // console.log(desiredText,'className set')
            const planLabel = document.createElement('span');
            // console.log(desiredText,'planLabel createElement')
            planLabel.className='plan-label-map'
            // console.log(desiredText,'planLabel plan-label-map')
            planLabel.textContent = 'Map';
            element.appendChild(planLabel);
            // console.log(desiredText,'planLabel appendChild')
            element.addEventListener('click', function () {
                console.log(desiredText)
                // console.log(map_button_dict[desiredText])
                updateMapDataAndFitBounds(map, map_button_dict[desiredText]);
            });
        }
    }
    observeDOMChanges();
    function updateMapDataAndFitBounds(map,geojson,target_labels=[]){
        function createCustomClusterIcon(cluster) {
            var childMarkers = cluster.getAllChildMarkers();
            var color = childMarkers[0].options.color; // è¯»å–è‡ªå®šä¹‰é¢œè‰²å±æ€§
            return L.divIcon({
                html: '<div class="custom-cluster-icon" style="background-color:' + color + ';">' + cluster.getChildCount() + '</div>',
                className: 'custom-cluster',
                iconSize: [40, 40]
            });
        }
        // ç¤ºä¾‹åˆ—è¡¨
        var markers = L.markerClusterGroup({
            iconCreateFunction: createCustomClusterIcon
        });

        console.log(target_labels)
        if (window.geoJsonLayer) {
            window.geoJsonLayer.clearLayers(); // ç§»é™¤ä¹‹å‰çš„å›¾å±‚æ•°æ®
        } else {
            window.geoJsonLayer = L.geoJSON().addTo(map); // åˆå§‹åŒ–geoJsonLayer

        }
        removeAllControls()
        function removeAllControls() {
            allControls.forEach(function(control) {
                map.removeControl(control);
            });
            allControls = []; // æ¸…ç©ºæ•°ç»„
        }

        function getRandomColor(label) {
            const label_belong =label.split("_").slice(0, 2).join("_");
            // const lastIndex = label.lastIndexOf("_"); // æ‰¾åˆ°æœ€åä¸€ä¸ªä¸‹åˆ’çº¿çš„ç´¢å¼•
            // const label_belong = label.substring(0, lastIndex);
            if (label_belong in color_dict){
                return color_dict[label_belong]
            }
            else
            {
                const color =picker.getNextElement()
                console.log(color,label_belong)
                color_dict[label_belong]=color
                return color;
            }


        }
        function createSequentialPicker(array) {
            if (!Array.isArray(array) || array.length === 0) {
                throw new Error("Array must be a non-empty array.");
            }
            function getNextElement() {
                // è·å–å½“å‰ç´¢å¼•çš„å…ƒç´ 
                const element = array[currentIndex];

                // æ›´æ–°ç´¢å¼•ï¼Œå¦‚æœåˆ°è¾¾æ•°ç»„æœ«å°¾åˆ™é‡ç½®ä¸º0
                currentIndex = (currentIndex + 1) % array.length;

                // è®°å½•å·²ç»æŠ½å–è¿‡çš„å…ƒç´ 
                usedElements.push(element);

                return element;
            }

            function getUsedElements() {
                return usedElements;
            }

            return {
                getNextElement,
                getUsedElements
            };
        }
        const picker = createSequentialPicker(color_list);
        function create_container_list(labels_ori,div){
            var blocks = {};
            let labels=[]
            let colors_btn={}

            const keys = Object.keys(labels_ori);

            // è·å–ç¬¬ä¸€ä¸ªå…ƒç´ çš„é”®å’Œå€¼
            const firstKey = keys[0];
            const firstValue = labels_ori[firstKey];

            // åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªå…ƒç´ æ·»åŠ è¿›å»
            const sortedObj = { [firstKey]: firstValue };

            // ç§»é™¤ç¬¬ä¸€ä¸ªå…ƒç´ çš„é”®
            keys.shift();

            // å¯¹å‰©ä½™çš„é”®è¿›è¡Œæ’åº
            keys.sort();

            // å°†æ’åºåçš„å…ƒç´ ä¾æ¬¡åŠ å…¥æ–°å¯¹è±¡
            keys.forEach(key => {
                sortedObj[key] = labels_ori[key];
            });
            // console.log(labels_ori)

            // console.log(sortedObj)
            for (var label in sortedObj) {
                (function(label) {
                    let color=labels_ori[label]['color']
                    colors_btn[label]=color
                    let layer=labels_ori[label]['layer']
                    if (!labels[label]) {

                        // è·å–ç¬¬ä¸€ä¸ªä¸‹åˆ’çº¿å‰é¢çš„å†…å®¹ä½œä¸ºblockçš„key
                        var blockKey = label.includes('_') ? "ğŸ’¾ "+label.split('_')[0] : 'ğŸ—ºï¸ Region';


                        if (!blocks[blockKey]) {
                            // å¦‚æœblockKeyä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„block
                            blocks[blockKey] = {
                                button: L.DomUtil.create('button', 'toggle-block-btn', div),
                                labels: {}
                            };
                            blocks[blockKey].button.style.backgroundColor = 'grey';
                            blocks[blockKey].button.textContent = blockKey;
                            blocks[blockKey].button.classList.add('block-button');
                            blocks[blockKey].button.onclick = function() {
                                var blockBtn = blocks[blockKey].button;
                                var labelsInBlock = blocks[blockKey].labels;
                                var allActive = true;

                                for (var lbl in labelsInBlock) {
                                    if (!map.hasLayer(labelsInBlock[lbl].layers[0])) {
                                        allActive = false;
                                        break;
                                    }
                                }

                                if (allActive) {
                                    for ( lbl in labelsInBlock) {
                                        labelsInBlock[lbl].layers.forEach(function(layer) {
                                            map.removeLayer(layer);
                                        });
                                        labelsInBlock[lbl].button.style.backgroundColor = 'black';
                                    }
                                } else {
                                    for ( lbl in labelsInBlock) {
                                        labelsInBlock[lbl].layers.forEach(function(layer) {
                                            map.addLayer(layer);
                                        });
                                        // console.log(lbl)
                                        // console.log(labelsInBlock[lbl])
                                        // console.log(colors[lbl])
                                        labelsInBlock[lbl].button.style.backgroundColor = colors_btn[lbl];
                                    }
                                }
                            };
                        }

                        // åˆ›å»ºä¸€ä¸ªæ–°çš„labelæŒ‰é’®
                        labels[label] = {
                            button: L.DomUtil.create('button', 'toggle-btn', div),
                            layers: []
                        };

                        labels[label].button.style.backgroundColor = color;

                        labels[label].button.textContent = target_labels.includes(label) ? label + " (target)" : label;
                        labels[label].button.onclick = function() {
                            var btn = labels[label].button;
                            var layers = labels[label].layers;
                            if (map.hasLayer(layers[0])) {
                                layers.forEach(function(layer) {
                                    map.removeLayer(layer);
                                });
                                btn.style.backgroundColor = 'black';
                            } else {
                                layers.forEach(function(layer) {
                                    map.addLayer(layer);
                                });

                                btn.style.backgroundColor = color;
                            }
                        };

                        // å°†å½“å‰labelæ·»åŠ åˆ°å¯¹åº”çš„blockä¸­
                        blocks[blockKey].labels[label] = labels[label];
                        // index++;
                    }
                    labels[label].layers=layer;
                })(label);
            }

        }
        var controls = L.control({position: 'topleft'});
        function push_obj(obj1, obj2) {
            Object.assign(obj1, obj2);
        }

        controls.onAdd = function(map) {
            var div = L.DomUtil.create('div', 'leaflet-control-custom');
            var labels = {}; // to keep track of unique labels


            for (var key in geojson) {
                (function(key) {
                    var parts = key.split('_');
                    const lastIndex = key.lastIndexOf("_"); // æ‰¾åˆ°æœ€åä¸€ä¸ªä¸‹åˆ’çº¿çš„ç´¢å¼•

                    var label = parts.length > 2 ? parts.slice(0, 2).join('_') : key;// use the second element as label or key if not present
                    var label_belong = key.substring(0, lastIndex); // use the second element as label or key if not present

                    var color = getRandomColor(key);
                    var feature = geojson[key];
                    var layerGroup = L.featureGroup();
                    var layerOptions = {
                        onEachFeature: function(feature, layer) {
                            layer.bindPopup(label_belong);
                            if (target_labels.includes(label)){
                                if (feature.type === 'Point') {
                                    latlng = L.latLng(feature.coordinates[1], feature.coordinates[0]);
                                } else {
                                    latlng = L.latLngBounds(layer.getBounds()).getCenter();
                                }

                                const layer_target=L.marker(latlng, {
                                    icon: L.divIcon({
                                        className: 'custom-div-icon',
                                        html:  `
            <div style="
                position: relative;
                width: 20px;
                height: 30px;
                background-color: transparent;">
                <div style="
                    width: 20px;
                    height: 20px;
                    background-color: ${color};
                    border: 2px solid white;
                    border-radius: 50%;
                    position: absolute;
                    top: 0;
                    left: 50%;
                    transform: translateX(-50%);
                    box-shadow: 0 0 0 2px ${color};">
                </div>

            </div>
        `,
                                        iconSize: [20, 20]
                                    }),
                                    color: color // å°†é¢œè‰²ä½œä¸ºè‡ªå®šä¹‰å±æ€§é™„åŠ åˆ°æ ‡è®°ä¸Š
                                })
                                markers.addLayer(layer_target)
                                layerGroup.addLayer(markers)
                                layer_target.bindPopup(label_belong);

                            }

                        }
                    };




                    if (feature.type === "Point") {
                        push_obj(layerOptions, {

                            pointToLayer: function (feature, latlng) {
                                return L.circleMarker(latlng, {
                                    radius: 5, // è°ƒæ•´åŠå¾„å¤§å°ä»¥æ”¹å˜ç‚¹çš„å¤§å°
                                    fillColor: color, //
                                    color:color, //
                                    weight: 1,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                });
                            },

                        });
                    }else {
                        push_obj(layerOptions, {

                            style: function(feature) {
                                return {color: color, weight: 2};
                            }
                        })
                    }
                    var layer = L.geoJSON(feature, layerOptions)
                    layerGroup.addLayer(layer)
                    layerGroup.addTo(window.geoJsonLayer);
                    if     ( !labels[label])  {
                        labels[label]={
                            color: color,
                            layer: [layerGroup]
                        }

                    }else {
                        labels[label]['layer'].push(layerGroup)
                    };







                })(key);
            }
            // console.log(labels)
            create_container_list(labels,div)
            return div;
        };
        controls.addTo(map);
        allControls.push(controls)

        // Create custom control for the toggle button
        var toggleControl = L.control({position: 'topleft'});
        toggleControl.onAdd = function(map) {
            var button = L.DomUtil.create('button', 'leaflet-control-toggle');
            // var rect = button.getBoundingClientRect();
            // console.log('æ§ä»¶çš„ä½ç½®:', rect);
            // console.log(button.style.top)
            button.innerHTML = 'â¬†ï¸';

            button.onclick = function() {
                var controlsDiv = document.querySelector('.leaflet-control-custom');
                const windowHeight = window.innerHeight;
                const controlsHeight = controlsDiv.offsetHeight;
                if (controlsDiv.style.top === '50px'||controlsDiv.style.top === '') {
                    controlsDiv.style.top = -controlsHeight+'px';// Adjust based on your actual controls height
                    button.innerHTML = 'â¬‡ï¸';
                    // console.log(controlsHeight)
                } else {
                    controlsDiv.style.top = '50px';
                    button.innerHTML = 'â¬†ï¸';
                }
            };
            return button;
        };
        toggleControl.addTo(map);
        allControls.push(toggleControl)

        // var controlInstance = control.addTo(map);

        // Toggle button for collapsing control panel
        // var toggle = document.getElementById('toggle');


        var expandControl = L.control({position: 'bottomleft'});

        expandControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'leaflet-control-expand');
            div.innerHTML = '<button id="expandBtn" style="background: #fff; border: none; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.3); padding: 8px 15px; cursor: pointer;">Expand</button>';
            return div;
        };


        expandControl.addTo(map);
        allControls.push(expandControl)
        var mapElement = document.getElementById('map-container');
        var expandBtn = document.getElementById('expandBtn');

        expandBtn.onclick = function() {
            if (mapElement.classList.contains('fullscreen')) {
                mapElement.classList.remove('fullscreen');
                expandBtn.textContent = 'Expand';
            } else {
                mapElement.classList.add('fullscreen');
                expandBtn.textContent = 'Shrink';
            }
            map.invalidateSize(); // Leaflet needs to adjust to new container size
        };

        // Listen for escape key to shrink map if in fullscreen
        document.addEventListener('keydown', function(event) {
            if (event.key === "Escape" && mapElement.classList.contains('fullscreen')) {
                mapElement.classList.remove('fullscreen');
                expandBtn.textContent = 'Expand';
                map.invalidateSize(); // Adjust map after resizing
            }
        });
        try {
            map.fitBounds(window.geoJsonLayer.getBounds());
        } catch (error) {
            console.log('Error fitting bounds:', window.geoJsonLayer.getBounds());
        }

    }

    var map = L.map('map-container', {
        doubleClickZoom: false,
        zoomControl: false // Disable the zoom control
    }).setView([48.145, 11.550], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
        opacity: 0.3  // è®¾ç½®é€æ˜åº¦ä¸º50%
    }).addTo(map);
    // æ›´æ–°åœ°å›¾æ•°æ®å¹¶è‡ªåŠ¨ç¼©æ”¾ä»¥é€‚åº”æ‰€æœ‰å…ƒç´ 
    // updateMapDataAndFitBounds(map, newPolygons);

    // updateMapDataAndFitBounds(map,geojsons)


    var messages=[]
    const normal_prompt = `
    You have following tools available to answer user queries, please only write python code:
I have three kinds of data:buildings, land (different kinds of area,points,lines...), soil.
1.set_bounding_box(address):
Input:An address which you want search limited in.
Output:None, it establishes a global setting that restricts future searches to the defined region.
Usage:By providing an address, you can limit the scope of subsequent searches to a specific area. This function does not produce any output, but it establishes a global setting that restricts future searches to the defined region. For example, if you want to find buildings in Munich, you should first set the bounding box to Munich by using set_bounding_box("Munich").
Notice:Please include the directional words like east/south/east/north of query in the address sent to set_bounding_box
Notice:If user does not query in a specific area, do not use this function. If user wants to search in all area, call set_bounding_box('').

2.id_list_of_entity(description of entity):
Input: Description of the entity, including adj or prepositional phrase like good for commercial,good for planting potatoes, or just entity word like 'technical university'.
Output: A list of IDs (id_list) corresponding to the described entity.
Usage: Use this function to obtain an id_list which will be used as input in the following functions.
Notice: Some times the description may have complex description like:"I want to know land which named see and is water", input the whole description into function.
Notice: Do not input geographical relation like 'in/on/under/in 200m of/close' into this function, it is not description of entity.

3.geo_filter('their geo_relation',id_list_subject, id_list_object):
Input: Two id_lists (one as subject and one as object) and their corresponding geographical relationship.
Output: A dict contains 'subject','object' two keys as filtered id_lists based on the geographical relationship.
Usage: This function is used only when the user wants to query multiple entities that are geographically related. Common geographical relationships are like: 'in/on/under/in 200m of/close/contains...'
Notice: id_list_subject should be the subject of the geo_relation, in example: soil under the buildings, soil is subject; buildings around water, buildings are subject.
Notice: Get the filtered subject/object id_list: result['subject'],result['object']

4.area_filter(id_list, num):
Notice: only use it when user wants to filter result by area.
Input: An id_list and a number representing either the maximum or minimum count.
Output: An id_list filtered by area.
Usage: Use this function only when the user explicitly asks for the entities with the largest or smallest areas. For example, input 3 for the largest three, and -3 for the smallest three.

5.id_list_explain(variable name, category to explain(name or type or area or attributes)):
Input: id_list generated by function 'id_list_of_entity' or 'geo_filter' or 'area_filter'
Output: A dictionary containing the count of each type/name occurrence or area sizeï¼ˆunit is square metersï¼‰.
Usage: Use this function to provide explanations based on user queries.

Please always set an output variable for each function you called and write corresponding short code comments.
Variable in history is available to call.
If user ask you to draw a diagram, please always use the true variable in previous code to draw but not assume fake value. If you asked to draw multi graph at the same time, you need to use subplots to draw them on a single figure.
 `
    //         `
    //
    // Example:
    // Query:I want to know largest 4 commerical buildings in 200 m of land which is forest
    //
    // Response:
    // ${String.fromCharCode(96)}python
    // id_list_buildings=id_list_of_entity('commerical buildings')
    // id_list_forest=id_list_of_entity('land which is forest')
    // id_list_buildings,id_list_forest=geo_filter(id_list_buildings,id_list_forest,'in 200 m of')
    // id_list_area_filtered_buildings=area_filter(id_list_buildings, 4)
    // ${String.fromCharCode(96)}
    // `

    messages.push({"role": "system",
        "content": normal_prompt
    })
    var socket = io();  // è¿æ¥WebSocketæœåŠ¡å™¨

    socket.on('connect', function() {
        socket.emit('join', {'username': 'user1', 'room': 'room1'});
    });

    socket.on('text', function(data) {
        // console.log('Received message:', data);
        if ("data" in data){

            // console.log(map_button_dict)
            messages.push(...data.data)
            const elements = document.querySelectorAll('.message-text.response');

            // è·å–æœ€åä¸€ä¸ª.message-text.responseå…ƒç´ 
            const lastElement = elements[elements.length - 1];

            // åœ¨æœ€åä¸€ä¸ª.message-text.responseå…ƒç´ ä¸­æ‰¾åˆ°æ‰€æœ‰.custom-rectå…ƒç´ 
            const customRects = lastElement.querySelectorAll('.custom-rect');
            customRects.forEach(rect => {
                if  (rect.className !== 'map-button' && !rect.classList.contains('map-button')){



                    const divClone = rect.cloneNode(true);

                    // ç§»é™¤å…‹éš†å…ƒç´ ä¸­çš„ <span> å…ƒç´ 
                    const span = divClone.querySelector('.plan-label');
                    if (span) {
                        span.remove();
                    }
                    const span_map = divClone.querySelector('.plan-label-map');
                    if (span_map) {
                        span_map.remove();
                    }

                    // è·å–å‰©ä½™æ–‡æœ¬å†…å®¹ï¼Œå¹¶å»é™¤å‰åçš„ç©ºæ ¼
                    const desiredText = divClone.textContent.trim();
                    // console.log(desiredText)

                    if (desiredText in map_button_dict) {

                        console.log(desiredText,'button set',rect)
                        // rect.classList.remove('custom-rect');
                        rect.className='map-button';
                        // console.log(desiredText,'className set')
                        const planLabel = document.createElement('span');
                        // console.log(desiredText,'planLabel createElement')
                        planLabel.className='plan-label-map'
                        // console.log(desiredText,'planLabel plan-label-map')
                        planLabel.textContent = 'Map';
                        rect.appendChild(planLabel);
                        // console.log(desiredText,'planLabel appendChild')
                        rect.addEventListener('click', function () {
                            console.log(desiredText)
                            // console.log(map_button_dict[desiredText])
                            updateMapDataAndFitBounds(map, map_button_dict[desiredText]);
                        });
                    }
                }

            });
            // map_button_dict={}
            // console.log(messages)
        }
        else if("map" in data) {
            //
            updateMapDataAndFitBounds( map,data.map,data['target_label']);
            console.log(data['target_label'])
            add_map_button(data.map,data['index'])
            //     document.getElementById('map-container').innerHTML=data.map
        }

        else if("sid" in data) {
            //
            sid=data['sid']
            //     document.getElementById('map-container').innerHTML=data.map
        }



        // åœ¨è¿™é‡Œå¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
    });
    const myP = document.getElementById('my-p');

    // åœ¨<p>æ ‡ç­¾è¢«ç‚¹å‡»æ—¶å¼¹å‡º"123"
    myP.addEventListener('click', () => {
        alert('è¯·è”ç³»å¾®ä¿¡å·: 18302921075');
    });

    $(document).ready(function() {

            var chatInput=$('#inputField')
            var submitButton = $('#confirmButton')
            var submit_email=$('#submit_email')

            $('#file-input').on('change', function() {
                var fileInput = document.getElementById('file-input');
                var file = fileInput.files[0];
                var formData = new FormData();
                formData.append('file', file);

                fetch('/upload', {
                    method: 'POST',
                    body: formData,
                })
                    .then(response => response.json())
                    .then(data => {
                        if(data.filename) {
                            var filenameShort = data.filename.slice(-10);
                            document.getElementById('upload-btn').value = ".."+filenameShort;
                            process_input("User upload a file in: .\\uploads\\"+data.filename)

                        } else {
                            alert('Upload failed');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Upload error');
                    });
            })
            function handleEnter(e){
                if (e.keyCode===13){
                    console.log("enter")
                    submitButton.click();
                    e.preventDefault();  //é¿å…å›è½¦æ¢è¡Œ
                }
            }

            // ç»‘å®šEnteré”®ç›˜äº‹ä»¶
            chatInput.on("keydown",handleEnter);

            var chatWindow = $('#chatWindow');
            function adjustContainerHeight() {
                var windowHeight = $(window).height(); // è·å–çª—å£çš„é«˜åº¦
                var containerHeight = windowHeight - 100; // çª—å£é«˜åº¦å‡å»100px
                // chatWindow.css('height', containerHeight + 'px'); // è®¾ç½®å®¹å™¨çš„é«˜åº¦
            }

            // é¦–æ¬¡åŠ è½½æ—¶è°ƒæ•´å®¹å™¨é«˜åº¦
            adjustContainerHeight();

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–äº‹ä»¶ï¼Œå¹¶è°ƒæ•´å®¹å™¨é«˜åº¦
            $(window).resize(adjustContainerHeight);
            // const chatWindow = document.getElementById('markdownContainer');
            function escapeHtml(html) {
                let text = document.createTextNode(html);
                let div = document.createElement('div');
                div.appendChild(text);
                return div.innerHTML;
            }

            function addRequestMessage(message) {
                // $(".answer .tips").css({"display":"none"});    // æ‰“èµå¡éšè—
                // chatInput.val('');
                let escapedMessage = escapeHtml(message);  // å¯¹è¯·æ±‚messageè¿›è¡Œè½¬ä¹‰ï¼Œé˜²æ­¢è¾“å…¥çš„æ˜¯htmlè€Œè¢«æµè§ˆå™¨æ¸²æŸ“
                let requestMessageElement = $('<div class="row message-bubble"><img class="chat-icon" src="./static/images/avatar.png"><div class="message-text request">' +  escapedMessage + '</div></div>');
                chatWindow.append(requestMessageElement);
                let responseMessageElement = $('<div class="row message-bubble"><img class="chat-icon" src="./static/images/chatgpt.png"><div class="message-text response"><span class="loading-icon"><i class="fa fa-spinner fa-pulse fa-2x"></i></span></div></div>');
                chatWindow.append(responseMessageElement);
                chatWindow.scrollTop(chatWindow.prop('scrollHeight'));
            }
            function addResponseMessage(message) {
                let lastResponseElement = $(".message-bubble .response").last();
                lastResponseElement.empty();
                let escapedMessage;

                // å¤„ç†ä»¥><;.å¼€å¤´çš„è¡Œ
                message = message.split('\n').map(line => {
                    if (line.startsWith('#><;')) {
                        if ((line.includes('englischer garten')||line.includes('Englischer Garten'))&&line.includes('ID')) {
                            console.log(first_time_englischer_garten_error)
                            // if (first_time_englischer_garten_error){
                            // first_time_englischer_garten_error=false
                            // return `<!--<div class="custom-rect map-button"><span class="plan-label">Step</span><span class="plan-label-map">Map</span>${escapeHtml(line.substring(4))}</div>-->`;

                            // }
                            // else {
                            return `<div class="custom-rect"><span class="plan-label">Step</span>${escapeHtml(line.substring(4))}</div>`

                        }else {
                            return `<div class="custom-rect"><span class="plan-label">Step</span>${escapeHtml(line.substring(4))}</div>`
                        }


                    } else {
                        return line;
                    }
                }).join('\n');

                // å¤„ç†æµå¼æ¶ˆæ¯ä¸­çš„ä»£ç å—
                let codeMarkCount = 0;
                let index = message.indexOf('```');
                while (index !== -1) {
                    codeMarkCount++;
                    index = message.indexOf('```', index + 3);
                }
                if (codeMarkCount % 2 == 1) {  // æœ‰æœªé—­åˆçš„ code
                    escapedMessage = marked.parse(message + '\n\n```');
                } else if (codeMarkCount % 2 == 0 && codeMarkCount != 0) {
                    escapedMessage = marked.parse(message);  // å“åº”æ¶ˆæ¯markdownå®æ—¶è½¬æ¢ä¸ºhtml
                } else if (codeMarkCount == 0) {  // è¾“å‡ºçš„ä»£ç æœ‰å¯èƒ½ä¸æ˜¯markdownæ ¼å¼ï¼Œæ‰€ä»¥åªè¦æ²¡æœ‰markdownä»£ç å—çš„å†…å®¹ï¼Œéƒ½ç”¨escapeHtmlå¤„ç†åå†è½¬æ¢
                    escapedMessage = marked.parse(message);
                }
                lastResponseElement.append(escapedMessage);
                $(".chat-window").scrollTop($(".chat-window").prop('scrollHeight'));
            }

            function escapeHtml(text) {
                var map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#039;'
                };
                return text.replace(/[&<>"']/g, function(m) { return map[m]; });
            }
            function cut_messages(originalArray){
                if (originalArray.length > 5) {
                    // æå–ç¬¬ä¸€ä¸ªå…ƒç´ 
                    const firstElement = originalArray.slice(0, 1);
                    // æå–æœ€åå››ä¸ªå…ƒç´ 
                    const lastFourElements = originalArray.slice(-4);
                    // ç»“åˆè¿™ä¸¤éƒ¨åˆ†
                    const newArray = firstElement.concat(lastFourElements);
                    console.log(newArray); // è¾“å‡º: [1, 7, 8, 9, 10]
                    return newArray
                } else {
                    // å¦‚æœæ•°ç»„é•¿åº¦ä¸è¶…è¿‡5ï¼Œç›´æ¥ä½¿ç”¨åŸæ•°ç»„
                    console.log(originalArray);
                    return originalArray
                }

            }
            document.getElementById('debug_mode').addEventListener('click', function() {
                // å‘é€ AJAX è¯·æ±‚åˆ°åå°
                var button = this;
                var message
                // å¦‚æœæŒ‰é’®å½“å‰æ²¡æœ‰çº¢è‰²æ ·å¼ï¼Œåˆ™æ·»åŠ ï¼Œå¦åˆ™ç§»é™¤
                if (!button.classList.contains('red-button')) {
                    button.classList.add('red-button');
                    message='debug'
                } else {
                    message='not debug'
                    button.classList.remove('red-button');
                }
                fetch('/debug_mode', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({message:message})
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Response from server:', data);
                        // è¿™é‡Œå¯ä»¥æ ¹æ®åå°è¿”å›çš„æ•°æ®æ‰§è¡Œä¸€äº›æ“ä½œ
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });

            });
            function process_input(userInput){
                if (userInput!==""){
                    addRequestMessage(userInput)
                    messages=cut_messages(messages)
                    // messages.push({"role":"user","content":userInput})
                    document.getElementById('inputField').value=''
                    // ä½¿ç”¨ fetch å‘é€æ•°æ®
                    fetch('/submit', {
                        method: 'POST', // æŒ‡å®šè¯·æ±‚æ–¹æ³•ä¸ºPOST
                        headers: {
                            'Content-Type': 'application/json', // æŒ‡å®šå‘é€çš„æ•°æ®ç±»å‹ä¸º JSON
                        },
                        body: JSON.stringify({ text: userInput ,'messages':messages,'new_message':userInput,'sid':sid}) // å°†ç”¨æˆ·è¾“å…¥è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                    })
                        .then(response => {
                            // response.json()



                            const reader = response.body.getReader();
                            var sum_chunk=""
                            function read() {
                                reader.read().then(({done, value}) => {
                                    if (done) {
                                        // messages.push({"role":"assistant","content":sum_chunk})
                                        // console.log('length',messages.length);
                                        return;
                                    }
                                    const chunk = new TextDecoder().decode(value); // å°†æµå­—èŠ‚è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                                    sum_chunk+=chunk
                                    // const tempDiv = document.createElement('div'); // åˆ›å»ºä¸€ä¸ªä¸´æ—¶ div ç”¨äºè§£æ HTML
                                    // chatWindow.innerHTML += chunk; // å°† HTML å­—ç¬¦ä¸²è®¾ç½®ä¸º div çš„å†…å®¹

                                    addResponseMessage(sum_chunk)

                                    read(); // ç»§ç»­è¯»å–ä¸‹ä¸€ä¸ªæ•°æ®å—
                                });
                            }
                            read();


                        }) // è§£æJSONæ ¼å¼çš„å“åº”
                        .then(data => {
                            console.log('Success:', data); // åœ¨æ§åˆ¶å°æ‰“å°æˆåŠŸçš„å“åº”
                        })
                        .catch((error) => {
                            console.error('Error:', error); // åœ¨æ§åˆ¶å°æ‰“å°å‡ºç°çš„é”™è¯¯
                        });
                }
            }
            document.getElementById('confirmButton').addEventListener('click', function() {
                document.getElementById('title').style.display="none"
                document.getElementById('chatWindow').style.display='block'
                // document.getElementById('subscribe').style.display='none'
                // document.getElementById('submit_email').style.display='none'
                document.getElementById('map-container').style.visibility='visible'
                var userInput = document.getElementById('inputField').value; // è·å–æ–‡æœ¬æ¡†çš„å€¼/
                process_input(userInput)

            });
            // document.getElementById('submit_email').addEventListener('click', function() {
            //
            //     const text=document.getElementById('subscribe').value
            //     document.getElementById('subscribe').value=''
            //     alert("é‚®ç®±æäº¤æˆåŠŸï¼è°¢è°¢å•¦:)")
            //     fetch('/submit_email', {
            //         method: 'POST', // æŒ‡å®šè¯·æ±‚æ–¹æ³•ä¸ºPOST
            //         headers: {
            //             'Content-Type': 'application/json', // æŒ‡å®šå‘é€çš„æ•°æ®ç±»å‹ä¸º JSON
            //         },
            //         body: JSON.stringify({ text: text }) // å°†ç”¨æˆ·è¾“å…¥è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
            //     })
            //         .then(response => {
            //
            //
            //         }) // è§£æJSONæ ¼å¼çš„å“åº”
            //         .then(data => {
            //         })
            //         .catch((error) => {
            //             console.error('Error:', error); // åœ¨æ§åˆ¶å°æ‰“å°å‡ºç°çš„é”™è¯¯
            //         });
            //     // var userInput = document.getElementById('inputField').value; // è·å–æ–‡æœ¬æ¡†çš„å€¼
            //     // process_input(userInput)
            //
            // });

        }
    )

    // æ·»åŠ å“åº”æ¶ˆæ¯åˆ°çª—å£,æµå¼å“åº”æ­¤æ–¹æ³•ä¼šæ‰§è¡Œå¤šæ¬¡


</script>



</body>
</html>
prompt="""
You are an AI assistant that processes complex database queries. Below are the functions you can use:

{

    "find_bounding_box": {
        "Argument": ["region_name"],
        "Description": "If user wants to get query result from a specific location, you need to first run this function with argument region_name, then the other function would limit its result in this region automatically (you don't need to add region name to other function). Example: if user wants to search result from munich germany, input of this function would be ['munich germany']."
    },
    "list_type_of_graph_name": {
        "Argument": ["graph_name"],
        "Description": "Enter the name of the graph you want to query and it returns all types of that graph. For example, for a soil graph, the types are different soil types."
    },
    "list_id_of_type": {
        "Arguments": ["graph_name", "type_name"],
        "Description": "Enter the graph name and type name you want to query, and it returns the corresponding element IDs.
                        If you want to get element_list from multi types at the same time, you can input arg type_name as a list."
        "Example":"
                
        If user wants to search soil that suitable for agriculture,
        first you need to figure out what kind of soil the soil graph have using list_type_of_graph_name,
            "command": {
        "command": "list_type_of_graph_name",
        "args": ["http://example.com/soil"],
        "variable": "soil_type"
    },
        then input type list you think is good for agriculture(please pick its full name but not only index of this type), and use list_id_of_type to get its element_list
                    "command": {
        "command": "list_id_of_type",
        "args": ["http://example.com/soil",[type list]],
        "variable": "soil_id"
    },
        
        "
    },

        "geo_calculate": {
        "Arguments": [element_list_1, element_list_2,"function name",buffer_number=0],
        "Description": "
        geo_calculate function has functions: contains, intersects, buffer. 
        Input should be two element_list which generated by function list_id_of_type and function name you want to use. 
        
        function contains: return which id in element_list_2 geographically contains which id in element_list_1
        function intersects: return which id in element_list_2 geographically intersects which id in element_list_1
        function buffer: return which id in element_list_2 geographically intersects the buffer of which id in element_list_1, if you want to call buffer, you need to specify the last argument "buffer_number" as a number.
        "Example":
        If user wants to search buildings in farmland, 
        first you need to figure out farmland and buildings in which graph using function list_type_of_graph_name,
        then generate element_list for buildings and farmland using function list_id_of_type, 
        "command": {
        "command": "list_id_of_type",
        "args": ["http://example.com/buildings", "building"]
        "variable":"element_list1"
        },
        "command": {
        "command": "list_id_of_type",
        "args": ["http://example.com/landuse", "farmland"]
        "variable":"element_list2"
        },
        finally call geo_calculate(element_list_1,element_list_2,"contains").
        "command": {
        "command": "geo_calculate",
        "args": ["element_list1", "element_list2","contains"]
        "variable":"contains_list"
        }
        "
    }
}
"""

tools = [{
    "type": "function",
    "function": {
        "name": "element_list_of_type",
        "description": "get element id list of specific type in specific category",
        "parameters": {
            "type": "object",
            "properties": {
                "category_name": {
                    "type": "string",
                    "enum": ['http://example.com/landuse', 'http://example.com/soil',
                             'http://example.com/buildings'],
                    "description": f"the category user wants to search, you need to select the one has most "
                                   f"similar semantic meaning",
                },
                "type_name": {
                    "type": "string",
                    "description": "type that user wants to search",
                },

                'region_name':{
                    "type": "string",
                    "description": "region generated by find_bounding_box",
                }

            },
            "required": ["category_name", "type_name",'region_name']
        },
    }
},
    {
        "type": "function",
        "function": {
            "name": "list_type_of_category",
            "description": "Get type list of specific category, there are three categories:landuse, soil, buildings. "
                           "You need to run this function to find correct type name of item in user's question."
                           "If user wants to search forest, you need to run list_type_of_category with arg landuse "
                           "and find out which type in generated type list is most similar to forest.",
            "parameters": {
                "type": "object",
                "properties": {
                    "category_name": {
                        "type": "string",
                        "enum": ['http://example.com/landuse', 'http://example.com/soil',
                                 'http://example.com/buildings'],
                        "description": f"the category user wants to search, you need to select the one has "
                                       f"most similar semantic meaning",
                    },

                },
                "required": ["category_name"],
            },
        }
    },
    {
        "type": "function",
        "function": {
            "name": "pick_match",
            "description": "pick_match takes two parameters: a list and a string for paring. It returns the most "
                           "similar items from list.",
            "parameters": {
                "type": "object",
                "properties": {
                    "input_list": {
                        "type": "list",
                        "description": f"the list you want to search in",
                    },
                    "descriptive_phrase": {
                        "type": "string",
                        "description": f"the type of element you want to get",
                    },

                },
                "required": ["input_list",'descriptive_phrase'],
            },
        }
    },

    {
        "type": "function",
        "function": {
            "name": "find_bounding_box",
            "description": "If user wants to get query result from a specific location, you need to first run this "
                           "function with argument region_name, then the other functions would limit its result in "
                           "this region automatically. Example: "
                           "if user wants to search result from munich germany, input of find_bounding_box function "
                           "would be ['munich germany'].",

            "parameters": {
                "type": "object",
                "properties": {
                    "region_name": {
                        "type": "string",
                        "description": f"the region name you want to search",
                    },

                },
                "required": ["region_name"],
            },
        }
    },
    {
        "type": "function",
        "function": {
            "name": "area_calculate", 
            "description": "area_calculate function takes two arguments: element_list(generated from "
                           "element_list_of_type or geo_calculate['subject']/geo_calculate['object']) and a number, "
                           "and it returns the top 'n' elements with the largest areas from the given list.", 

            "parameters": {
                "type": "object",
                "properties": {
                    "element_list": {
                        "type": "list",
                        "description": f"element_list(generated from "
                           "element_list_of_type or geo_calculate['subject'] / geo_calculate['object'])",
                    },                    
                        "top_num": {
                        "type": "int",
                        "description": f"top 'n' elements with the largest areas from the given list.",
                    },

                },
                "required": ["element_list",'top_num'],
            },
        }
    },
    {
        "type": "function",
        "function": {
            "name": "geo_calculate",
            "description": "geo_calculate function can handle three geo relationships: contains, intersects, "
                           "buffer. Input should be two element_list which generated by function element_list_of_type "
                           "and geo relationship user wants to search. Return a dict with keys: 'object' and "
                           "'subject', means the result element_list of object and subject in this geo_relationship",

            "parameters": {
                "type": "object",
                "properties": {
                    "subject_element_list": {
                        "type": "string",
                        "description": f"the subject_element_list in search",
                    },
                    "object_element_list": {
                        "type": "string",
                        "description": f"the object_element_list in search",
                    },
                    "function_name": {
                        "type": "string",
                        "enum": ['contains', 'intersects',
                                 'buffer'],
                        "description": f"the geo relationship user wants to search.",
                    },
                    "buffer_number": {
                        "type": "integer",
                        "description": f"if the geo relationship user asked is about buffer area, then you need to "
                                       f"input a integer value as "
                                       f"buffer_number.",
                    },

                },
                "required": ["subject_element_list", 'object_element_list', 'function_name'],
            },
        }
    },

]
tools_back=[
    {
        ''
    }
]
simiplified_tools=[]
for i in tools:
    # print(i['function'])
    simiplified_tools.append({'function':i['function']['name'],'description':i['function']['description'],'arguments':i['function']['parameters']['required']})

    print(simiplified_tools[-1])
